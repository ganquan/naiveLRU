# NaiveLRUCache

```c
// LRU本质上是解决两个问题
// 1、缓存查找性能
// 2、缓存的增、删、改性能，而且要求缓存有序
// 最快的查找必然是哈希表
// 增、删、改性能最好的是双向链表
// 所以LRUCache的底层数据结构就是哈希表和双链表，结合这两个数据结构的优点解决两个问题
// LRU缓存的实现考察，其实是一个很好的综合考察题目
// 重要的两个基础数据结构都覆盖到了
// 多线层安全的话，有两个解决思路
// 1、直接用锁，这个是最容易想到的办法。但是一不小心会搞出死锁来，要小心。
// 2、用串行队列再封一层，把所有需要上锁的行为，都通过队列串行化
// 但可能需要调整代码，以确保一些行为进队列后依旧可以保证是紧挨着直行的，而不会被其他线程插入的任务打断
// 站在考察候选人的立场来看，如果候选人可以把LRU理解和实现都搞清楚，基本上可以认为数据结构基础是没有问题的

```


# NaiveLFUCache
```c
// LFU比LRU多一个freq - ValueList的map
// 如果是刷题的话，不考虑多线层加锁，能够获得微量提升
// 从工程实践的角度来看，考虑应该全面一点
// 通过实现LFU、LRU
// 利用POP、泛型抽象、层次设计等思路，尽量压缩了代码
// LFU和LRU都是很不错的练手题目
```